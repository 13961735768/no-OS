/*
 * Copyright 2018 (c) Analog Devices, Inc.
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *  - Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *  - Neither the name of Analog Devices, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *  - The use of this software may or may not infringe the patent rights
 *    of one or more patent holders.  This license does not release you
 *    from the requirement that you obtain separate licenses from these
 *    patent holders to use this software.
 *  - Use of the software either in source or binary form, must be run
 *    on or directly connected to an Analog Devices Inc. component.
 *
 * THIS SOFTWARE IS PROVIDED BY ANALOG DEVICES "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, NON-INFRINGEMENT,
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL ANALOG DEVICES BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, INTELLECTUAL PROPERTY RIGHTS, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

/******************************************************************************/
/***************************** Include Files **********************************/
/******************************************************************************/

#include "platform_drivers.h"
#include "ad9144.h"
#include "dac_core.h"
#include "dmac_core.h"
#include "dac_buffer.h"
#include "xcvr_core.h"
#include "jesd_core.h"

/******************************************************************************/
/********************** Macros and Constants Definitions **********************/
/******************************************************************************/

#define GPIO_DAC_TXEN_0 32
#define GPIO_DAC_TXEN_1 33
#define GPIO_SPI_EN     35

#define DMA_BUFFER 0

#if DMA_BUFFER

static void dac_dma_setup(dac_core *dac_core)
{
	dmac_core dac_dma;
	dmac_xfer tx_xfer;

	dac_dma.base_address = XPAR_DAC_DMA_BASEADDR;

#ifdef ZYNQ
	tx_xfer.start_address = XPAR_DDR_MEM_BASEADDR + 0x900000;
#endif

#ifdef MICROBLAZE
	tx_xfer.start_address = XPAR_AXI_DDR_CNTRL_BASEADDR + 0x900000;
#endif

	dac_dma.type = DMAC_TX;
	dac_dma.transfer = &tx_xfer;
	dac_dma.flags = DMAC_FLAGS_TLAST;

	tx_xfer.id = 0;
	tx_xfer.no_of_samples = dac_buffer_load(dac_core, tx_xfer.start_address);

	if(!dmac_start_transaction(dac_dma))
		ad_printf("Transmit data from memory\n");
}
#endif

static int ad9516_spi_write(spi_desc *spi_desc, uint16_t reg_addr, uint8_t reg_data)
{
	uint8_t buf[3];

	buf[0] = reg_addr >> 8;
	buf[1] = reg_addr & 0xFF;
	buf[2] = reg_data;

	return spi_write_and_read(spi_desc, buf, 3);
}

static int32_t ad9516_setup(const spi_init_param *init_param)
{
	spi_desc *spi_desc;

	/* Setup SPI descriptor */
	spi_init(&spi_desc, init_param);

	/* TODO: Add AD9516 driver */

	/* Soft reset */
	ad9516_spi_write(spi_desc, 0x00, 0x3c);
	ad9516_spi_write(spi_desc, 0x00, 0x18);

	/*
	 * Configure the clock chip to forward the external clock signal to both DAC
	 * and the FPGA. SYSREF is generated by diving the signal by 32.
	 */

	/* Use external clock */
	ad9516_spi_write(spi_desc, 0x1E1, 0x01);
	/* Enable OUT1 */
	ad9516_spi_write(spi_desc, 0x0f1, 0x00);
	/* Enable OUT6 */
	ad9516_spi_write(spi_desc, 0x140, 0x42);
	/* Enable OUT7 */
	ad9516_spi_write(spi_desc, 0x141, 0x42);
	/* Enable OUT9 */
	ad9516_spi_write(spi_desc, 0x143, 0x42);
	/* Set OUT6/OUT7 divider to 32 */
	ad9516_spi_write(spi_desc, 0x199, 0x33);
	ad9516_spi_write(spi_desc, 0x19b, 0x11);
	/* Bypass OUT9 divider */
	ad9516_spi_write(spi_desc, 0x1A1, 0x30);
	/* Assert SYNC */
	ad9516_spi_write(spi_desc, 0x230, 0x01);
	/* Transfer all registers */
	ad9516_spi_write(spi_desc, 0x232, 0x01);

	/* Deassert SYNC */
	ad9516_spi_write(spi_desc, 0x230, 0x00);
	ad9516_spi_write(spi_desc, 0x232, 0x01);

	spi_remove(spi_desc);

	return 0;
}

static int dac_check_link(dac_core *dac_core, struct ad9144_dev *ad9144_device,
	struct ad9144_init_param *ad9144_param)
{
	int ret = 0;

	/* If the link is not up skip the data pattern tests. They'll fail anyway */
	if (ad9144_status(ad9144_device) != 0)
		return -1;

	#define DAC_M0_S0 0xa1a0
	#define DAC_M0_S1 0xb1b0
	#define DAC_M1_S0 0xc1c0
	#define DAC_M1_S1 0xd1d0

	#define DAC_PATTERN_DATA(a, b) (((a) << 16) | (b))

	dac_core->channels[0].pat_data = DAC_PATTERN_DATA(DAC_M0_S1, DAC_M0_S0);
	dac_core->channels[1].pat_data = DAC_PATTERN_DATA(DAC_M1_S1, DAC_M1_S0);

	ad9144_param->stpl_samples[0][0] = DAC_M0_S0;
	ad9144_param->stpl_samples[0][1] = DAC_M0_S1;
	ad9144_param->stpl_samples[0][2] = DAC_M0_S0;
	ad9144_param->stpl_samples[0][3] = DAC_M0_S1;

	ad9144_param->stpl_samples[1][0] = DAC_M1_S0;
	ad9144_param->stpl_samples[1][1] = DAC_M1_S1;
	ad9144_param->stpl_samples[1][2] = DAC_M1_S0;
	ad9144_param->stpl_samples[1][3] = DAC_M1_S1;

	/* Short pattern transport layer test */
	dac_core->channels[0].sel = DAC_SRC_SED;
	dac_core->channels[1].sel = DAC_SRC_SED;
	dac_data_setup(dac_core);

	ad9144_short_pattern_test(ad9144_device, ad9144_param);

	/* PRBS test is not supported in mode 8 and mode 11 */
	if (ad9144_param->jesd204_mode == 8 || ad9144_param->jesd204_mode == 11)
		return ret;

	/* PN7 data path test */
	dac_core->channels[0].sel = DAC_SRC_PN7;
	dac_core->channels[1].sel = DAC_SRC_PN7;
	dac_data_setup(dac_core);
	ad9144_param->prbs_type = AD9144_PRBS7;
	ret |= ad9144_datapath_prbs_test(ad9144_device, ad9144_param);

	/* PN15 data path test */
	dac_core->channels[0].sel = DAC_SRC_PN15;
	dac_core->channels[1].sel = DAC_SRC_PN15;
	dac_data_setup(dac_core);
	ad9144_param->prbs_type = AD9144_PRBS15;
	ret |= ad9144_datapath_prbs_test(ad9144_device, ad9144_param);

	return ret;
}

int main(void)
{
	uint32_t link_rate;
	spi_init_param ad9144_spi_param;
	spi_init_param ad9516_spi_param;

#ifdef ALTERA
	ad9516_spi_param.type = NIOS_II_SPI;
	ad9144_spi_param.type = NIOS_II_SPI;
#endif
#ifdef ZYNQ_PS7
	ad9516_spi_param.type = ZYNQ_PS7_SPI;
	ad9144_spi_param.type = ZYNQ_PS7_SPI;
#endif
#ifdef ZYNQ_PSU
	ad9516_spi_param.type = ZYNQ_PSU_SPI;
	ad9144_spi_param.type = ZYNQ_PSU_SPI;
#endif
#ifdef MICROBLAZE
	ad9516_spi_param.type = MICROBLAZE_SPI'
	ad9144_spi_param.type = MICROBLAZE_SPI;
#endif

	ad9516_spi_param.chip_select = SPI_CHIP_SELECT(0);
	ad9516_spi_param.cpha = 0;
	ad9516_spi_param.cpol = 0;

	ad9144_spi_param.chip_select = SPI_CHIP_SELECT(1);
	ad9144_spi_param.cpha = 0;
	ad9144_spi_param.cpol = 0;

	struct ad9144_init_param ad9144_param;

	ad9144_param.spi_init = ad9144_spi_param;

	struct ad9144_dev *ad9144_device;

	dac_core		ad9144_core;
	dac_channel		ad9144_channels[2];
	jesd_core		ad9144_jesd;
	xcvr_core		ad9144_xcvr;
	int ret;

	gpio_desc *spi_en_gpio;

	/* Needs to be set to 1 to allow SPI communication from the FPGA */
	gpio_get(&spi_en_gpio, GPIO_SPI_EN);
	gpio_set_value(spi_en_gpio, 1);

	ad9516_setup(&ad9516_spi_param);
	mdelay(10);

	ad9144_xcvr.base_address = XPAR_DAC_JESD204_XCVR_BASEADDR;
	ad9144_core.base_address = XPAR_DAC_JESD204_TRANSPORT_BASEADDR;
	ad9144_jesd.base_address = XPAR_DAC_JESD204_LINK_TX_AXI_BASEADDR;

	#define PRIu32 "lu"

start:

	link_rate = axi_jesd204_get_link_rate_khz(&ad9144_jesd);
	if (link_rate) {
		ad_printf("Device clock: %"PRIu32" kHz\n", link_rate);
	} else {
		ad_printf("No device clock detected. Assuming 100 MHz.\n");
		link_rate = 100000;
	}

	ad9144_xcvr.ref_clock_khz = link_rate;

	xcvr_getconfig(&ad9144_xcvr);
	ad9144_jesd.rx_tx_n = 0;
	ad9144_jesd.scramble_enable = 1;
	ad9144_jesd.octets_per_frame = 1;
	ad9144_jesd.frames_per_multiframe = 32;
	ad9144_jesd.subclass_mode = 1;

	ad9144_channels[0].dds_dual_tone = 0;
	ad9144_channels[0].dds_frequency_0 = 33*1000*1000;
	ad9144_channels[0].dds_phase_0 = 0;
	ad9144_channels[0].dds_scale_0 = 500000;
	ad9144_channels[1].dds_dual_tone = 0;
	ad9144_channels[1].dds_frequency_0 = 11*1000*1000;
	ad9144_channels[1].dds_phase_0 = 0;
	ad9144_channels[1].dds_scale_0 = 500000;
	ad9144_channels[0].sel = DAC_SRC_DDS;
	ad9144_channels[1].sel = DAC_SRC_DDS;

	ad9144_core.channels = ad9144_channels;
	ad9144_core.no_of_channels = 2;

	ad9144_param.spi3wire = 0;
	ad9144_param.interpolation = 1;
	ad9144_param.pll_enable = 1;
	ad9144_param.pll_ref_frequency_khz = link_rate;
	ad9144_param.pll_dac_frequency_khz = link_rate * 8;
	ad9144_param.sample_rate_khz = ad9144_param.pll_dac_frequency_khz;
	ad9144_param.jesd204_subclass = 1;
	ad9144_param.jesd204_scrambling = 1;
	ad9144_param.jesd204_mode = 11;
	ad9144_param.jesd204_lane_xbar[0] = 0;
	ad9144_param.jesd204_lane_xbar[1] = 1;
	ad9144_param.jesd204_lane_xbar[2] = 2;
	ad9144_param.jesd204_lane_xbar[3] = 3;
	ad9144_param.jesd204_lane_xbar[4] = 4;
	ad9144_param.jesd204_lane_xbar[5] = 5;
	ad9144_param.jesd204_lane_xbar[6] = 6;
	ad9144_param.jesd204_lane_xbar[7] = 7;

	ad9144_xcvr.reconfig_bypass = 0;
	ad9144_xcvr.lane_rate_kbps = ad9144_jesd204_get_lane_rate_kbps(&ad9144_param);

	/*
	 * Use QPLL if possible. There is a gap in the supported lane rates between
	 * 4 Gbps and 4.9 Gbps. Use the CPLL to cover that range.
	 */
	if (ad9144_xcvr.lane_rate_kbps < 4900000 &&
	    ad9144_xcvr.lane_rate_kbps > 4000000)
		ad9144_xcvr.dev.qpll_enable = 0;
	else
		ad9144_xcvr.dev.qpll_enable = 1;

	ad_printf("Lanerate: %"PRIu32" kbps\n", ad9144_xcvr.lane_rate_kbps);

	/* Setup TX enable GPIOs */
	gpio_desc *dac_txen[2];

	gpio_get(&dac_txen[0], GPIO_DAC_TXEN_0);
	gpio_get(&dac_txen[1], GPIO_DAC_TXEN_1);
	gpio_set_value(dac_txen[0], 0);
	gpio_set_value(dac_txen[1], 0);

	/*
	 * Recommended DAC JESD204 link startup sequence
	 *   1. FPGA JESD204 Link Layer
	 *   2. FPGA JESD204 PHY Layer
	 *   3. DAC
	 */

	jesd_setup(&ad9144_jesd);
	xcvr_setup(&ad9144_xcvr);
	ad9144_setup(&ad9144_device, &ad9144_param);

	/* JESD204 core status */
	axi_jesd204_tx_status_read(&ad9144_jesd);

	/* Interface core set up */
	dac_setup(&ad9144_core);

	ret = dac_check_link(&ad9144_core, ad9144_device, &ad9144_param);
	if (ret == 0) {
		/* Only enable the outputs if the link is up */
		gpio_set_value(dac_txen[0], 1);
		gpio_set_value(dac_txen[1], 1);
	} else {
		printf("Failed to initialize JESD204 link.\n");
	}

#if DMA_BUFFER
	ad9144_channels[0].sel = DAC_SRC_DMA;
	ad9144_channels[1].sel = DAC_SRC_DMA;
	dac_data_setup(&ad9144_core);

	dac_dma_setup(&ad9144_core);
#else
	ad9144_channels[0].sel = DAC_SRC_DDS;
	ad9144_channels[1].sel = DAC_SRC_DDS;
	dac_data_setup(&ad9144_core);
#endif

	printf("Setup and configuration is done\n");

	uint8_t c;
	int reset = 0;

	while (!reset) {
		printf("\n");
		printf("Choose an action:\n");
		printf("s) Show status\n");
		printf("r) Restart\n");

		do {
			c = ad_uart_read();
		} while (c <= 32 || c > 126); /* Ignore non printable characters */

		printf ("%c\n", c);

		switch (c) {
		case 's':
			printf("\n");
			axi_jesd204_tx_status_read(&ad9144_jesd);
			ad9144_status(ad9144_device);
			ad9144_report_lane_errors(ad9144_device);
			break;
		case 'r':
			printf("Restarting...\n\n");
			reset = 1;
			break;
		default:
			break;
		}
	}

	/* Release device */
	ad9144_remove(ad9144_device);

	/* Release GPIOs */
	gpio_remove(dac_txen[0]);
	gpio_remove(dac_txen[1]);

goto start;

	return(0);
}
